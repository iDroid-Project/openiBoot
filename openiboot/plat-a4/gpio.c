#include "openiboot.h"
#include "arm/arm.h"
#include "gpio.h"
#include "interrupt.h"
#include "hardware/gpio.h"
#include "clock.h"
#include "util.h"
#include "timer.h"
#include "spi.h"
#include "chipid.h"
#include "hardware/power.h"

typedef struct {
	uint32_t flags[32];
	uint32_t token[32];
	InterruptServiceRoutine handler[32];
} GPIOInterruptGroup;

GPIOInterruptGroup InterruptGroups[GPIO_NUMINTGROUPS];

static void gpio_handle_interrupt(uint32_t token);
void gpio_custom_io(int pinport, int mode);

#if !defined(CONFIG_IPAD_1G)
const uint16_t gpio_reset_table[] = {
	0x210, 0x210, 0x390, 0x390, 0x210, 0x290, 0x213, 0x212,
	0x213, 0x212, 0x213, 0x290, 0x290, 0x390, 0x212, 0x1E,
	0x212, 0x212, 0x390, 0x212, 0x212, 0x290, 0x212, 0x390,
	0x210, 0x1E, 0x290, 0x212, 0x1E, 0x1E, 0x213, 0x212,
	0x390, 0x290, 0x212, 0x1E, 0x390, 0x390, 0x390, 0x1E,
	0x1E, 0x1E, 0x630, 0x630, 0x630, 0x213, 0x630, 0x630,
	0x630, 0x212, 0x630, 0x630, 0x630, 0x212, 0x630, 0x630,
	0x630, 0x630, 0x630, 0x630, 0x1E, 0x1E, 0x630, 0x630,
	0x613, 0x630, 0x630, 0x630, 0x630, 0x630, 0x230, 0x230,
	0x230, 0x1E, 0x1E, 0x230, 0x230, 0x250, 0x250, 0x230,
	0x230, 0xA30, 0xA30, 0xA30, 0xA30, 0xAB0, 0xAB0, 0xBB0,
	0xBB0, 0xAB0, 0xAB0, 0xAB0, 0xAB0, 0xAB0, 0xAB0, 0xAB0,
	0xAB0, 0x81E, 0x81E, 0x81E, 0x81E, 0xA30, 0xA30, 0xA30,
	0xA30, 0xAB0, 0xAB0, 0xBB0, 0xBB0, 0xAB0, 0xAB0, 0xAB0,
	0xAB0, 0xAB0, 0xAB0, 0xAB0, 0xAB0, 0x1E, 0xA30, 0x230,
	0x212, 0x230, 0x213, 0x212, 0x630, 0x630, 0x630, 0x630,
	0x630, 0x630, 0x630, 0x630, 0x630, 0x630, 0x630, 0x630,
	0x630, 0x630, 0x630, 0x1E, 0x212, 0x1E, 0x230, 0x630,
	0x630, 0xE30, 0xFB0, 0xFB0, 0xFB0, 0xFB0, 0xFB0, 0x81E,
	0x81E, 0x81E, 0x81E, 0x1E, 0x1E, 0x1E, 0x210, 0x210,
	0x210, 0x212, 0x210, 0x212, 0x1E, 0x210, 0x210, 0x212,
	0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
};
#else
const uint16_t gpio_reset_table[] = {
	0x210, 0x210, 0x390, 0x390, 0x210, 0x212, 0x1E, 0x612,
	0x1E, 0x612, 0x612, 0x210, 0x210, 0x390, 0x612, 0x613,
	0x1E, 0x210, 0x390, 0x612, 0x612, 0x290, 0x212, 0x613,
	0x612, 0x1E, 0x210, 0x212, 0x1E, 0x1E, 0x210, 0x1E,
	0x1E, 0x390, 0x212, 0x390, 0x390, 0x390, 0x390, 0x1E,
	0x1E, 0x1E, 0xA30, 0xA30, 0xA30, 0x613, 0xA30, 0xA30,
	0xA30, 0x612, 0xA30, 0xA30, 0xA30, 0x612, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0x613, 0x613, 0xA30, 0xA30,
	0xA13, 0xA30, 0x213, 0x9E, 0x613, 0x41E, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA50, 0xA50, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30,
	0xA30, 0x212, 0x212, 0x212, 0x212, 0xA30, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0x212, 0xA30, 0x613,
	0x390, 0xA30, 0x612, 0xA12, 0x1E, 0xA30, 0xA30, 0xA30,
	0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0xA30, 0x1E, 0xA30,
	0xA30, 0xA30, 0xA30, 0x213, 0x212, 0x1E, 0x230, 0xA30,
	0xA30, 0xA30, 0xBB0, 0xBB0, 0xBB0, 0xBB0, 0xBB0, 0x212,
	0x212, 0x612, 0x212, 0x212, 0x212, 0x612, 0x612, 0x212,
	0x212, 0x612, 0x610, 0x612, 0x612, 0x210, 0x210, 0x212,
	0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
};
#endif


int gpio_setup() {
	// Initialise it
	uint8_t v[8];
	if (!(GET_REG(POWER + POWER_ID) & 1)) {
		gpio_custom_io(0x502, 0);
		gpio_custom_io(0x503, 0);
		gpio_custom_io(0x504, 0);
		gpio_pulldown_configure(0x502, GPIOPDDown);
		gpio_pulldown_configure(0x503, GPIOPDDown);
		gpio_pulldown_configure(0x504, GPIOPDDown);
		gpio_custom_io(0x202, 0);
		gpio_custom_io(0x301, 0);
		gpio_custom_io(0x304, 0);
		gpio_custom_io(0x305, 0);
		gpio_pulldown_configure(0x202, GPIOPDDown);
		gpio_pulldown_configure(0x301, GPIOPDDown);
		gpio_pulldown_configure(0x304, GPIOPDDown);
		gpio_pulldown_configure(0x305, GPIOPDDown);
		udelay(100);
		v[0] = chipid_get_gpio_epoch();
		v[1] = gpio_pin_state(0x504);
		v[2] = gpio_pin_state(0x503);
		v[3] = gpio_pin_state(0x502);
		v[4] = gpio_pin_state(0x305);
		v[5] = gpio_pin_state(0x304);
		v[6] = gpio_pin_state(0x301);
		v[7] = gpio_pin_state(0x202);
		gpio_custom_io(0x502, 4);
		gpio_custom_io(0x503, 4);
		gpio_custom_io(0x504, 4);
		gpio_custom_io(0x202, 4);
		gpio_custom_io(0x301, 4);
		gpio_custom_io(0x304, 4);
		gpio_custom_io(0x305, 4);
		uint32_t new_status = ((v[0] << 3 | v[1] << 2 | v[2] << 1 | v[3]) << 16) | ((v[4] << 3 | v[5] << 2 | v[6] << 1 | v[7]) << 8) | 1;
		SET_REG(POWER + POWER_ID, (GET_REG(POWER + POWER_ID) & 0xFF000000) | (new_status & 0xFFFFFF));
	}

	interrupt_install(GPIO_INTERRUPT, gpio_handle_interrupt, 0);
	interrupt_enable(GPIO_INTERRUPT);

	return 0;
}

static void gpio_handle_interrupt(uint32_t token) {
	bufferPrintf("gpio: Interrupt!\r\n");
}

void gpio_register_interrupt(uint32_t interrupt, int type, int level, int autoflip, InterruptServiceRoutine handler, uint32_t token) {
	return;
}

void gpio_interrupt_enable(uint32_t interrupt) {
	return;
}

void gpio_interrupt_disable(uint32_t interrupt) {
	return;
}

int gpio_pin_state(int port) {
	uint8_t pin = port & 0x7;
	port = port >> 8;

	if (port == 0x16) {
		//return spi_status(pin);
		return 0;
	} else {
		return (GET_REG(GPIO + (8 * port + pin) * sizeof(uint32_t)) & 1);
	}
}

void gpio_pin_use_as_input(int port) {
	gpio_custom_io(port, 0);
}

void gpio_pin_output(int pinport, int bit) {
	uint8_t port = (pinport >> 8) & 0xFF;

	if (port == 0x16) {
//		sub_5FF0EF38(pinport, bit); // SPI related, not yet, sorry.
	} else {
		gpio_custom_io(pinport, (bit&1)+2);
	}
}

void gpio_pulldown_configure(int port, GPIOPDSetting setting)
{
	uint32_t pin_register = GPIO + (((port >> 5) & 0x7F8) + ((port & 0x7)<<2));

	switch(setting) {
		case GPIOPDDisabled:
			SET_REG(pin_register, (GET_REG(pin_register) & (~(0x3<<7))));
			break;

		case GPIOPDUp:
			SET_REG(pin_register, ((GET_REG(pin_register) & (~(0x3<<7))) | (0x3<<7)));
			break;

		case GPIOPDDown:
			SET_REG(pin_register, ((GET_REG(pin_register) & (~(0x3<<7))) | (0x1<<7)));
			break;
	}
}

void gpio_custom_io(int pinport, int mode) {
	uint8_t pin = pinport & 0x7;
	uint8_t port = (pinport >> 8) & 0xFF;
	uint16_t bitmask;
	uint16_t value;
	uint32_t pin_register;
	if (port == 0x16) {
		//spi_on_off(pin, mode);
	} else {
		pin_register = GPIO + (8 * port + pin) * sizeof(uint32_t);
		switch(mode)
		{
		case 0: // use_as_input
			value = 0x210;
			bitmask = 0x27E;
			break;

		case 1: // use_as_output
			value = 0x212;
			bitmask = 0x27E;
			break;

		case 2: // clear_output
			value = 0x212;
			bitmask = 0x27F;
			break;

		case 3: // set_output
			value = 0x213;
			bitmask = 0x27F;
			break;

		case 4: // reset
			value = gpio_reset_table[8 * port + pin];
			bitmask = 0x3FF;
			break;

		case 5:
			value = 0x230;
			bitmask = 0x27E;
			value &= ~0x10;
			break;

		case 6:
			value = 0x250;
			bitmask = 0x27E;
			value &= ~0x10;
			break;

		case 7:
			value = 0x270;
			bitmask = 0x27E;
			value &= ~0x10;
			break;

		default:
			return;
		}
	SET_REG(pin_register, (GET_REG(pin_register) & (~bitmask)) | (value & bitmask));
	}
}
